# 2023数算第⼀章作业

## 1.

> 请计算下⾯程序中赋值语句的执⾏次数，并给出计算过程（要求是计算准确的 次数⽽不是算法复杂度的阶，其中n为正整数）。
>
> ```cpp
> for (i = 1; i < n; i++){
> 	for (j = n; j >= i; j--){
> 		a[i][j] = 1;
> 	}
> }
> ```

---

考虑

```cpp
for (i = 1; i < n; i++)
```

的过程，可知循环结束时`i == n`，故一共进行了 $n-1$ 次`i++`，而$n - 1 = \sum_{i\in[1,n)}1$。

运用类似方法知，

```cpp
for (j = n; j >= i; j--)
```

一共进行了 $n-i+1 = \sum_{j\in[i,n]}1$ 次`j--`.

故而，由程式知 $答案 =\sum_{i=1}^{n-1}(1_{\tt i++} + \sum_{j\in[i,n]}(1_{\tt j--}+1_{\tt a[i][j] = 1})))$。 

计算即得（$i,j$为整数）：
$$
\begin{aligned}
	答案 &= \sum_{i=1}^{n-1}\left(1+\sum_{j\in[i,n]}2\right) \\
		&= \sum_{i=1}^{n-1}\left(1+2(n-i+1)\right) \\
		&= \sum_{i=1}^{n-1}(2n-2i+3) \\
		&= (n-1)(2n+3) - 2\sum_{i=1}^{n-1} i \\
		&= 2n^2 + n - 3 + n(n-1)\\
		&= \boxed{3n^2 - 3}
\end{aligned}
$$

## 2.

> 已知下列运算时间函数，写出其⼤O表示的运算时间 (第⼆⼩题请求出T(n)的表达式，给出计算过程并通过数学归纳法证明)

### (1)

> $T(n) = 3n^3 + 10n^2 + 2n$

$$
T(n) = \boxed{O(n^3)}
$$

### (2)

> $T(n) = 2T(n-1) + 1, T(1) = 1$

计算可得 $n=1,2,3,4$ 时 $T(n)$ 的值为 $1,3,7,15$，猜测 $T(n) = 2^n - 1$。

下通过数学归纳法证明之：

1. $n = 1$时，$T(1) = 1 = 2^1 - 1$。

2. 假设 $n = k$ 时 $T(n) = 2^n - 1$ 成立，现证明 $n = k+1$ 时也成立：
   $$
   T(k+1) = 2T(k) + 1 = 2(2^k - 1) + 1= 2^{k+1} - 1
   $$
   得证。

由数学归纳法即证$T(n) = 2^n - 1$，故
$$
T(n) = \boxed{O(2^n)}
$$

## 3.

> 3、证明下列两个问题：

### (1)

> f(n)和g(n)是两个⾮负渐进函数，请根据 θ 表示法的定义，证明max(f(n), g(n)) = θ(f(n) + g(n))。 

令$h(n) = \max(f(n), g(n))$，由定义 $0\le f(n), g(n) \le h(n)$，且有 $h(n) = f(n)$ 成立或 $h(n) = g(n)$成立。

故 $\forall n$ 有：
$$
\frac{f(n) + g(n)}{2}\le \frac{h(n)}{2} + \frac{h(n)}{2} = h(n) \le f(n) + g(n)
$$
 故由 $\Theta$ 表示法的定义，
$$
h(n) = \Theta(f(n) + g(n))
$$
证毕。

### (2)

> 对于任意实数 $a > b > 1, b^n = O(a^n)$，但 $a^n \ne O(b^n)$

因为 $\forall n\ge 1$ 有 $b^n < a^n$，故由 $O$-表示法的定义：
$$
b^n = O(a^n)
$$
因为 $\forall k > 0$ 都可以找到 $n > \ln_{\frac{a}{b}} k$ 使得
$$
\begin{aligned}
\left(\frac{a}{b}\right)^n &> k \\
a^n &> kb^n
\end{aligned}
$$
故
$$
a^n \ne O(b^n)
$$
证毕。

# 2023数算第二章作业

## 1.

>  已知⼀顺序表A有n个元素，其元素值递减有序排列，编写⼀个算法删除顺序表中多余的值相同的元素。要求：空间复杂度为O(1)，并分析代码的时间复杂度。

---

代码如下（假设$n \ge 1$）：

```cpp
int uniq(int A[], int n) {
	int new_n = 1; // 默认保留A[0]。
	for (int i = 1; i < n; ++i) {
		if (A[i] != A[i-1]) A[new_n++] = A[i]; // 如果A[i]和之前的元素不同，就保留它，并延长预定保留的元素序列。
	}
	return new_n; // 返回新顺序表的长度。
}
```

因为做的操作是in-place的，且只用了一个变量`new_n`，所以空间复杂度是$O(1)$的。

循环外的赋值与返回语句是$O(1)$的。

循环中的`if`语句是$O(1)$的，共执行$n-1$次，故循环的时间复杂度为$O(n)$。

故而，总的时间复杂度为$O(n)$。

## 2.

> 写出将单链表置逆的算法，输⼊⼀个链表的头结点，反转该链表并输出反转后链表的头结点。要求尽可能少地使⽤附加单元，并分析算法的时间和空间复杂度。

---

假设这个单链表用`nxt[]`数组存储，用`-1`标记表尾：

```cpp
int reverse(int head, int nxt[]) {
  int current_node = head; // 从表头head开始遍历，
  int previous_node = -1; // 此时的表头head在新的列表中为表尾，需要用nxt[head] = -1来标记，
  while (current_node != -1) { // 遍历这个表
    int next_node = nxt[current_node]; // 获取当前节点的下一个节点。
    nxt[current_node] = previous_node; // 把新表中当前节点的“下一个节点”设为原表中的“上一个节点”
    previous_node = current_node, current_node = next_node; // 移动到原表中的下一个节点，更新 current_node 与 previous_node 为原表中的对应值。
  }
  return previous_node; // 此时已经到达原表的表尾， current_node = -1，故返回 previous_node。
}
```

因为只用了`current_node`、`new_next_node`、`next_node`这三个额外变量，故空间复杂度是$O(1)$的。

因为代码实际上是遍历了一遍单链表，一边遍历一边做$O(1)$的操作，所以复杂度是$O(单链表表长)$的。

## 3.

> 请设计算法判断⼀个单向链表 L 是否有环，并分析你所设计算法的时间复杂度 和空间复杂度。要求：不允许修改给定的链表。

使用Floyd的$\rho$算法来判环：

```cpp
bool detect_cycle(int head, int nxt[]) { // 有环返回1，无环返回0
  int turtle = head; // “乌龟”走的慢，一次走一格
  int hare = head; // “兔子”走的快，一次走两格
  
  while (hare != -1) {
    
    hare = nxt[hare];
    if (hare == -1) return 0; // “兔子”完成遍历，原表无环
    hare = nxt[hare];
    
    turtle = nxt[turtle];
    
    if (turtle == hare) return 1; // “兔子”和“乌龟”相遇，原表有环
  }
  
  return 0; // “兔子”完成遍历，原表无环
}
```

该代码在无环的情况时，“兔子”不可能会追上“乌龟”，而是会先一步遍历完原表，故而一定会返回`0`。此时的复杂度显然是$O(表长)$的，因为它相当于遍历了1.5遍原表。

该代码在有环的情况时，我首先说明它一定会终止：在“乌龟”和“兔子”都进入环时，每过一轮，“兔子”都会离“乌龟”更进一步，所以在$|环长|$轮之后算法必定会终止。

因为“乌龟”进入环前至多进行$表长-|环长|$轮，所以复杂度同样是$O(表长)$的。

因此，该算法的时间复杂度是$O(表长)$的，空间复杂度是$O(1)$的。